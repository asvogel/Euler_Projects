import math
##### Project Euler Problem 1:
def multiples(cap, *factors):
	# If we list all the natural numbers below 10 that are multiples 
		# of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples
		# is 23. Find the sum of all the multiples of 3 or 5 below 1000.
	# Method: create list of all multiples of user supplied factors 
		# less than the user supplied cap. Delete duplicates and sum.
	mylist = []
	for x in range(cap+1):
		for num in factors:
			if num*x < cap:
				mylist.append(num*x)
	mylist = list(dict.fromkeys(mylist))
	out = sum(mylist)
	return out
##### Project Euler Problem 2:
def fibs(cap,*factors):
	# Each new term in the Fibonacci sequence is generated by
		# adding the previous two terms. By considering the terms 
		# in the Fibonacci sequence whose values do not exceed four 
		# million, find the sum of the even-valued terms.
	# Method: create list of all fibonacci terms that are divisible by
		# any of the factors. Delete duplicates. Find sum.
	fib_nums = [2,1]
	mylist = [2]
	i = 1
	while fib_nums[1] < cap:
		fib_nums = [(fib_nums[1]+fib_nums[0]), fib_nums[0]]
		print(fib_nums)
		for num in factors:
			if (fib_nums[1]%num == 0):
				mylist.append(fib_nums[1])
	mylist = list(dict.fromkeys(mylist))
	out = sum(mylist)
	return out
##### Project Euler Problem 3:
def largest_prime(cap):
	# What is the largest prime factor of the number 600851475143 ?
	# Method: Use Sieve of Atkin to find all primes less than sqrt(num)
		# Find largest one that is a factor
	primes = sieve_of_atkin(cap)
	primes.sort(reverse=True)
	for num in primes:
		if (cap%num == 0):
			return num
	return 0
def sieve_of_atkin(ceiling):	
	cap = int(math.sqrt(ceiling))+1
	# We know 2 and 3 are prime.
	primes = [2,3]
	# Initialize the sieve with FALSE
	sieve = [False] * (cap+1)
	# sieve[n]=True if one of the following:
		# (a) n = (4*x*x)+(y*y) has an odd num of solutions
			# e.g. an odd number of (x,y) pairs exist that satisfy
			# n%12 = 1 or 5
		# (b) n = (3*x*x)+(y*y) has an odd num of solutions & n%12 = 7
		# (c) n = (3*x*x)-(y*y) has an odd num of solutions, x>y, 
			# and n%12=11
	x = 1
	while (x*x < cap):
		y = 1
		while (y*y < cap):
			# Part (a)
			n = (4*x*x)+(y*y)
			if (n <= cap and (n%12==1 or n%12==5)):
				sieve[n] ^= True
			# Part (b)
			n = (3*x*x)+(y*y)
			if (n <= cap and (n%12==7)):
				sieve[n] ^= True		
			# Part (c)
			n = (3*x*x)-(y*y)
			if (n <= cap and (n%12==11) and x>y):
				sieve[n] ^= True		
			y = y+1
		x = x+1
	# Remove all multiples of squares
	r = 5
	while (r*r<cap):
		if (sieve[r]):
			for i in range(r*r, cap, r*r):
				sieve[i]=False
		r=r+1
	for a in range(5, cap):
		if (sieve[a]):
			primes.append(a)
	return primes
##### Project Euler Problem 4:
def palind(dig):	
	# A palindromic number reads the same both ways. The largest
		# palindrome made from the product of two 2-digit numbers 
		# is 9009 = 91 Ã— 99.
		# Find the largest palindrome made from the product of 
			# two 3-digit numbers.
	# Method: Try all products of three digit numbers. Check if 
		# palindrome. Find max. Not the most elegant.
	num = (10**(dig)-1) # 999
	out = []
	i=0
	while (num >= 10**(dig-1)):
		while (i <= num-10**(dig-1)):
			if palindrome(num*(num-i)):
				out.append(num*(num-i))
			i = i+1
		num = num-1
		i = 0
	return max(out)
def palindrome(val):
	mylist = list(str(val))
	myrev = list(str(val))
	myrev.reverse()
	out = False
	for elem, val in enumerate(mylist):
		if (val != myrev[elem]):
			out = False
			return out
		else:
			out = True
	return out
	
print(palind(3))
